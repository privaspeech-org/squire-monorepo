import { z } from 'zod';

/**
 * Schema for a single task generated by the LLM
 */
export const TaskSchema = z.object({
  prompt: z.string()
    .min(10, 'Task prompt must be at least 10 characters')
    .max(2000, 'Task prompt must not exceed 2000 characters')
    .describe('Detailed description of the coding task to be performed'),

  priority: z.enum(['high', 'medium', 'low'])
    .describe('Task priority level: high for CI failures, medium for features, low for maintenance'),

  depends_on: z.array(z.string())
    .default([])
    .describe('Array of task IDs that must complete before this task can start'),
});

/**
 * Schema for the array of tasks returned by the LLM
 */
export const TaskArraySchema = z.array(TaskSchema);

/**
 * Type for a single task (inferred from schema)
 */
export type Task = z.infer<typeof TaskSchema>;

/**
 * Type for an array of tasks (inferred from schema)
 */
export type TaskArray = z.infer<typeof TaskArraySchema>;

/**
 * Schema validation error with helpful context
 */
export interface ValidationError {
  message: string;
  path: string[];
  received: unknown;
}

/**
 * Validate LLM response against task schema
 *
 * @param data - Unknown data to validate
 * @returns Validation result with success flag and data/errors
 */
export function validateTaskArray(data: unknown): {
  success: true;
  data: TaskArray;
} | {
  success: false;
  errors: ValidationError[];
} {
  const result = TaskArraySchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  // Transform Zod errors into more readable format
  const errors: ValidationError[] = result.error.issues.map((err) => ({
    message: err.message,
    path: err.path.map((p) => String(p)),
    received: err.path.reduce((obj: any, key) => obj?.[key], data),
  }));

  return { success: false, errors };
}

/**
 * Format validation errors into a human-readable string for LLM feedback
 *
 * @param errors - Array of validation errors
 * @returns Formatted error message
 */
export function formatValidationErrors(errors: ValidationError[]): string {
  if (errors.length === 0) return 'Unknown validation error';

  const errorMessages = errors.map(err => {
    const path = err.path.length > 0 ? ` at ${err.path.join('.')}` : '';
    return `- ${err.message}${path}`;
  });

  return `Validation errors:\n${errorMessages.join('\n')}`;
}

/**
 * Example tasks to include in the LLM prompt
 */
export const TASK_EXAMPLES = [
  {
    prompt: 'Fix failing CI build in packages/core: TypeError in container.ts line 145. The startTaskContainer function is missing null check for config.workerImage.',
    priority: 'high' as const,
    depends_on: [],
  },
  {
    prompt: 'Implement Phase 2.3 of backend improvement plan: Add structured error types (ContainerError, GitHubAPIError, LLMError) with error codes and retryable flags.',
    priority: 'medium' as const,
    depends_on: [],
  },
  {
    prompt: 'Update documentation in CLAUDE.md to reflect new configuration options for container timeouts and resource limits.',
    priority: 'low' as const,
    depends_on: [],
  },
];

/**
 * Generate JSON schema string for inclusion in prompts
 */
export function getSchemaDescription(): string {
  return `{
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "prompt": {
        "type": "string",
        "minLength": 10,
        "maxLength": 2000,
        "description": "Detailed description of the coding task"
      },
      "priority": {
        "type": "string",
        "enum": ["high", "medium", "low"],
        "description": "high=CI failures, medium=features, low=maintenance"
      },
      "depends_on": {
        "type": "array",
        "items": { "type": "string" },
        "default": [],
        "description": "Task IDs that must complete first"
      }
    },
    "required": ["prompt", "priority"]
  }
}`;
}
